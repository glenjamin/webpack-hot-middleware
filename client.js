/*eslint-env browser*/
/*global __resourceQuery __webpack_public_path__*/

var io = require('socket.io-client');
var parse = require('parse-uri');

var options = {
  port: 3000,
  path: '',
  timeout: 20 * 1000,
  overlay: true,
  reload: false,
  log: true,
  warn: true
};
if (__resourceQuery) {
  var querystring = require('querystring');
  var overrides = querystring.parse(__resourceQuery.slice(1));
  if (overrides.path) options.path = overrides.path;
  if (overrides.port) options.port = overrides.port;
  if (overrides.timeout) options.timeout = overrides.timeout;
  if (overrides.overlay) options.overlay = overrides.overlay !== 'false';
  if (overrides.reload) options.reload = overrides.reload !== 'false';
  if (overrides.noInfo && overrides.noInfo !== 'false') {
    options.log = false;
  }
  if (overrides.quiet && overrides.quiet !== 'false') {
    options.log = false;
    options.warn = false;
  }
  if (overrides.dynamicPublicPath) {
    options.path = __webpack_public_path__ + options.path;
  }
}

if (typeof window === 'undefined') {
  // do nothing
} else {
  connect();
}

function connect() {
  var uri = parse(options.path);
  var host = uri.host ? uri.host : window.location.hostname;
  var protocol = uri.protocol ? uri.protocol : window.location.protocol;

  var socketServer = protocol + "//" + host + ":" + options.port;

  var socket = io.connect(socketServer, {
    timeout: options.timeout
  });

  var lastActivity = new Date();

  socket.on('connect', function () {
    if (options.log) console.log("[HMR] connected");
    lastActivity = new Date();
  });

  socket.on('message', function(data) {
    lastActivity = new Date();
    try {
      processMessage(data);
    } catch (ex) {
      if (options.warn) {
        console.warn("Invalid HMR message: " + data + "\n" + ex);
      }
    }
  });
}

var reporter;
// the reporter needs to be a singleton on the page
// in case the client is being used by mutliple bundles
// we only want to report once.
// all the errors will go to all clients
var singletonKey = '__webpack_hot_middleware_reporter__';
if (typeof window !== 'undefined' && !window[singletonKey]) {
  reporter = window[singletonKey] = createReporter();
}

function createReporter() {
  var strip = require('strip-ansi');

  var overlay;
  if (typeof document !== 'undefined' && options.overlay) {
    overlay = require('./client-overlay');
  }

  return {
    problems: function(type, obj) {
      if (options.warn) {
        console.warn("[HMR] bundle has " + type + ":");
        obj[type].forEach(function(msg) {
          console.warn("[HMR] " + strip(msg));
        });
      }
      if (overlay && type !== 'warnings') overlay.showProblems(type, obj[type]);
    },
    success: function() {
      if (overlay) overlay.clear();
    },
    useCustomOverlay: function(customOverlay) {
      overlay = customOverlay;
    }
  };
}

var processUpdate = require('./process-update');

var customHandler;
var subscribeAllHandler;
function processMessage(obj) {
  switch (obj.action) {
    case "building":
      if (options.log) console.log("[HMR] bundle rebuilding");
      break;
    case "built":
      if (options.log) {
        console.log(
          "[HMR] bundle " + (obj.name ? obj.name + " " : "") +
          "rebuilt in " + obj.time + "ms"
        );
      }
      // fall through
    case "sync":
      if (obj.errors.length > 0) {
        if (reporter) reporter.problems('errors', obj);
      } else {
        if (reporter) {
          if (obj.warnings.length > 0) reporter.problems('warnings', obj);
          reporter.success();
        }
        processUpdate(obj.hash, obj.modules, options);
      }
      break;
    default:
      if (customHandler) {
        customHandler(obj);
      }
  }

  if (subscribeAllHandler) {
    subscribeAllHandler(obj);
  }
}

if (module) {
  module.exports = {
    subscribeAll: function subscribeAll(handler) {
      subscribeAllHandler = handler;
    },
    subscribe: function subscribe(handler) {
      customHandler = handler;
    },
    useCustomOverlay: function useCustomOverlay(customOverlay) {
      if (reporter) reporter.useCustomOverlay(customOverlay);
    }
  };
}
